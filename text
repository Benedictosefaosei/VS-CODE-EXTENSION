

//   context.subscriptions.push(
//   vscode.commands.registerCommand("extension.generateQA", async () => {
//     const ws = vscode.workspace.workspaceFolders?.[0];
//     if (!ws) {
//       vscode.window.showErrorMessage("No workspace folder is open.");
//       return;
//     }
//     const rootPath = ws.uri.fsPath;
//     const quizFile = path.join(rootPath, ".vscode", "quiz-questions.json");
//     if (!fs.existsSync(quizFile)) {
//       vscode.window.showErrorMessage("No quiz-questions.json found in .vscode folder.");
//       return;
//     }

//     // load questions
//     let questionsData: QAItem[];
//     try {
//       questionsData = JSON.parse(fs.readFileSync(quizFile, "utf8"));
//       if (!questionsData.length) {
//         vscode.window.showErrorMessage("quiz-questions.json exists but contains no questions.");
//         return;
//       }
//     } catch (err: any) {
//       vscode.window.showErrorMessage(`Error reading quiz-questions.json: ${err.message}`);
//       return;
//     }

//     // load config
//     const configPath = path.join(rootPath, "cqlc.config.json");
//     if (!fs.existsSync(configPath)) {
//       vscode.window.showErrorMessage("Config file cqlc.config.json not found in the workspace root.");
//       return;
//     }

//     let config: any;
//     try {
//       config = JSON.parse(fs.readFileSync(configPath, "utf8"));
//     } catch (err: any) {
//       vscode.window.showErrorMessage(`Error reading config file: ${err.message}`);
//       return;
//     }

//     const requiredFields = [
//       "title", "topic", "folder", "pl_root", "pl_question_root", "pl_assessment_root",
//       "set", "number", "points_per_question", "startDate", "endDate",
//       "timeLimitMin", "daysForGrading", "reviewEndDate", "language"
//     ];
//     for (const field of requiredFields) {
//       if (!config[field]) {
//         vscode.window.showErrorMessage(`Missing required field in config: ${field}`);
//         return;
//       }
//     }

//     // build base output paths
//     const questionsRoot = path.join(config.pl_root, "questions", config.pl_question_root, config.folder);
//     const assessmentsRoot = path.join(config.pl_root, config.pl_assessment_root, config.folder);
//     const instructorRoot = path.join(questionsRoot, "instructor");
//     const instructorAssessRoot = path.join(assessmentsRoot, "instructor");

//     [questionsRoot, assessmentsRoot, instructorRoot, instructorAssessRoot].forEach(p => {
//       if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
//     });

//     // group questions by student folder (first segment of filePath)
//     const questionsByStudent: Record<string, QAItem[]> = {};
//     for (const q of questionsData) {
//       const studentName = (q.filePath || "").split(/[\\/]/)[0] || "unknown_student";
//       if (!questionsByStudent[studentName]) questionsByStudent[studentName] = [];
//       questionsByStudent[studentName].push(q);
//     }

//     // generate student-specific files
//     for (const [student, qs] of Object.entries(questionsByStudent)) {
//       const studentQPath = path.join(questionsRoot, student);
//       const studentAssessPath = path.join(assessmentsRoot, student);
//       if (!fs.existsSync(studentQPath)) fs.mkdirSync(studentQPath, { recursive: true });
//       if (!fs.existsSync(studentAssessPath)) fs.mkdirSync(studentAssessPath, { recursive: true });

//       // create subfolder for each question
//       qs.forEach((question, index) => {
//         const questionFolder = path.join(studentQPath, `question${index + 1}`);
//         if (!fs.existsSync(questionFolder)) fs.mkdirSync(questionFolder, { recursive: true });

//         const outFile = path.join(questionFolder, `question${index + 1}.json`);
//         fs.writeFileSync(outFile, JSON.stringify(question, null, 2), "utf8");
//       });

//       // Generate infoAssessment.json for this student
//       const infoAssessment = {
//         uuid: generateUUID(), // You'll need to implement this function
//         type: "Exam",
//         title: config.title,
//         set: config.set,
//         number: config.number,
//         allowAccess: [
//           {
//             mode: "Public",
//             uids: [student],
//             credit: 100,
//             timeLimitMin: config.timeLimitMin,
//             startDate: config.startDate,
//             endDate: config.endDate,
//             password: "letMeIn"
//           },
//           {
//             mode: "Public",
//             credit: 0,
//             startDate: config.reviewEndDate ? new Date(new Date(config.reviewEndDate).getTime() + 24 * 60 * 60 * 1000).toISOString() : new Date(new Date(config.endDate).getTime() + 24 * 60 * 60 * 1000).toISOString(),
//             endDate: new Date(new Date(config.endDate).getTime() + 7 * 24 * 60 * 60 * 1000).toISOString(),
//             active: false
//           }
//         ],
//         zones: [
//           {
//             questions: qs.map((_, index) => ({
//               id: `${config.pl_question_root}/${config.folder}/${student}/question${index + 1}`,
//               points: config.points_per_question
//             }))
//           }
//         ]
//       };

//       const assessmentFile = path.join(studentAssessPath, "infoAssessment.json");
//       fs.writeFileSync(assessmentFile, JSON.stringify(infoAssessment, null, 2), "utf8");
//     }

//     vscode.window.showInformationMessage("Generated QA files with question subfolders and infoAssessment.json for all students.");
//   })
// );

  
  
  































  
//   context.subscriptions.push(
//   vscode.commands.registerCommand("extension.generateQA", async () => {
//     const ws = vscode.workspace.workspaceFolders?.[0];
//     if (!ws) {
//       vscode.window.showErrorMessage("No workspace folder is open.");
//       return;
//     }
//     const rootPath = ws.uri.fsPath;
//     const quizFile = path.join(rootPath, ".vscode", "quiz-questions.json");
//     if (!fs.existsSync(quizFile)) {
//       vscode.window.showErrorMessage("No quiz-questions.json found in .vscode folder.");
//       return;
//     }

//     // load questions
//     let questionsData: any[];
//     try {
//       questionsData = JSON.parse(fs.readFileSync(quizFile, "utf8"));
//       if (!questionsData.length) {
//         vscode.window.showErrorMessage("quiz-questions.json exists but contains no questions.");
//         return;
//       }
//     } catch (err: any) {
//       vscode.window.showErrorMessage(`Error reading quiz-questions.json: ${err.message}`);
//       return;
//     }

//     // load config
//     const configPath = path.join(rootPath, "cqlc.config.json");
//     if (!fs.existsSync(configPath)) {
//       vscode.window.showErrorMessage("Config file cqlc.config.json not found in the workspace root.");
//       return;
//     }

//     let config: any;
//     try {
//       config = JSON.parse(fs.readFileSync(configPath, "utf8"));
//     } catch (err: any) {
//       vscode.window.showErrorMessage(`Error reading config file: ${err.message}`);
//       return;
//     }

//     const requiredFields = [
//       "title", "topic", "folder", "pl_root", "pl_question_root", "pl_assessment_root",
//       "set", "number", "points_per_question", "startDate", "endDate",
//       "timeLimitMin", "daysForGrading", "reviewEndDate", "language"
//     ];
//     for (const field of requiredFields) {
//       if (!config[field]) {
//         vscode.window.showErrorMessage(`Missing required field in config: ${field}`);
//         return;
//       }
//     }

//     // build base output paths
//     const questionsRoot = path.join(config.pl_root, "questions", config.pl_question_root, config.folder);
//     const assessmentsRoot = path.join(config.pl_root, config.pl_assessment_root, config.folder);
//     const instructorRoot = path.join(questionsRoot, "instructor");
//     const instructorAssessRoot = path.join(assessmentsRoot, "instructor");

//     [questionsRoot, assessmentsRoot, instructorRoot, instructorAssessRoot].forEach(p => {
//       if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
//     });

//     // group questions by student folder (first segment of filePath)
//     const questionsByStudent: Record<string, any[]> = {};
//     for (const q of questionsData) {
//       const studentName = (q.filePath || "").split(/[\\/]/)[0] || "unknown_student";
//       if (!questionsByStudent[studentName]) questionsByStudent[studentName] = [];
//       questionsByStudent[studentName].push(q);
//     }

//     // generate student-specific files
//     for (const [student, qs] of Object.entries(questionsByStudent)) {
//       const studentQPath = path.join(questionsRoot, student);
//       const studentAssessPath = path.join(assessmentsRoot, student);
//       if (!fs.existsSync(studentQPath)) fs.mkdirSync(studentQPath, { recursive: true });
//       if (!fs.existsSync(studentAssessPath)) fs.mkdirSync(studentAssessPath, { recursive: true });

//       // create subfolder for each question
//       qs.forEach((question, index) => {
//         const questionFolder = path.join(studentQPath, `question${index + 1}`);
//         if (!fs.existsSync(questionFolder)) fs.mkdirSync(questionFolder, { recursive: true });

//         // Debug: Show what properties are available in the question object
//         console.log('Question properties:', Object.keys(question));
//         console.log('Question content:', question);

//         // Create question.html file - using the actual properties from your data
//         const questionText = question.question || question.text || question.content || "No question content available.";
//         const codeSnippet = question.code || question.highlightedCode || question.snippet || "// No code highlighted";

//         const questionHtmlContent = `
// <pl-question-panel>
// <markdown>
// ${questionText}
// </markdown>
//     <pl-code language="${config.language || 'python'}">
// ${codeSnippet}
// </pl-code>
// </pl-question-panel>
// `.trim();

//         const questionHtmlFile = path.join(questionFolder, "question.html");
//         fs.writeFileSync(questionHtmlFile, questionHtmlContent, "utf8");

//         // Create info.json file
//         const questionInfo = {
//           uuid: generateUUID(),
//           type: "v3",
//           gradingMethod: "Manual",
//           title: config.title,
//           topic: config.topic
//         };

//         const infoJsonFile = path.join(questionFolder, "info.json");
//         fs.writeFileSync(infoJsonFile, JSON.stringify(questionInfo, null, 2), "utf8");
//       });

//       // Generate infoAssessment.json for this student
//       const infoAssessment = {
//         uuid: generateUUID(),
//         type: "Exam",
//         title: config.title,
//         set: config.set,
//         number: config.number,
//         allowAccess: [
//           {
//             mode: "Public",
//             uids: [student],
//             credit: 100,
//             timeLimitMin: config.timeLimitMin,
//             startDate: config.startDate,
//             endDate: config.endDate,
//             password: "letMeIn"
//           },
//           {
//             mode: "Public",
//             credit: 0,
//             startDate: config.reviewEndDate ? new Date(new Date(config.reviewEndDate).getTime() + 24 * 60 * 60 * 1000).toISOString() : new Date(new Date(config.endDate).getTime() + 24 * 60 * 60 * 1000).toISOString(),
//             endDate: new Date(new Date(config.endDate).getTime() + 7 * 24 * 60 * 60 * 1000).toISOString(),
//             active: false
//           }
//         ],
//         zones: [
//           {
//             questions: qs.map((_, index) => ({
//               id: `${config.pl_question_root}/${config.folder}/${student}/question${index + 1}`,
//               points: config.points_per_question
//             }))
//           }
//         ]
//       };

//       const assessmentFile = path.join(studentAssessPath, "infoAssessment.json");
//       fs.writeFileSync(assessmentFile, JSON.stringify(infoAssessment, null, 2), "utf8");
//     }

//     vscode.window.showInformationMessage("Generated QA files with question.html, info.json, and infoAssessment.json for all students.");
//   })
// );

